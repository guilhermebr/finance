// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: finance.sql

package gen

import (
	"context"
	"time"

	uuid "github.com/gofrs/uuid/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"math/big"
)

const createAccount = `-- name: CreateAccount :one

INSERT INTO accounts (name, type, description)
VALUES ($1, $2, $3)
RETURNING id, name, type, description, created_at, updated_at
`

// =============================================================================
// ACCOUNTS
// =============================================================================
func (q *Queries) CreateAccount(ctx context.Context, name string, type_ string, description *string) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount, name, type_, description)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one

INSERT INTO categories (name, type, description, color)
VALUES ($1, $2, $3, $4)
RETURNING id, name, type, description, color, created_at, updated_at
`

// =============================================================================
// CATEGORIES
// =============================================================================
func (q *Queries) CreateCategory(ctx context.Context, name string, type_ string, description *string, color *string) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		name,
		type_,
		description,
		color,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one

INSERT INTO transactions (account_id, category_id, amount, description, date, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, account_id, category_id, amount, description, date, status, created_at, updated_at
`

// =============================================================================
// TRANSACTIONS
// =============================================================================
func (q *Queries) CreateTransaction(ctx context.Context, accountID uuid.UUID, categoryID uuid.UUID, amount big.Int, description string, date pgtype.Date, status string) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		accountID,
		categoryID,
		amount,
		description,
		date,
		status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTransaction, id)
	return err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, name, type, description, created_at, updated_at
FROM accounts
WHERE id = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountWithBalance = `-- name: GetAccountWithBalance :one
SELECT 
    a.id, a.name, a.type, a.description, a.created_at, a.updated_at,
    COALESCE(b.current_balance, 0) as current_balance,
    COALESCE(b.pending_balance, 0) as pending_balance,
    COALESCE(b.available_balance, 0) as available_balance
FROM accounts a
LEFT JOIN balances b ON a.id = b.account_id
WHERE a.id = $1
`

type GetAccountWithBalanceRow struct {
	ID               uuid.UUID `json:"id"`
	Name             string    `json:"name"`
	Type             string    `json:"type"`
	Description      *string   `json:"description"`
	CreatedAt        time.Time `json:"createdAt"`
	UpdatedAt        time.Time `json:"updatedAt"`
	CurrentBalance   big.Int   `json:"currentBalance"`
	PendingBalance   big.Int   `json:"pendingBalance"`
	AvailableBalance big.Int   `json:"availableBalance"`
}

func (q *Queries) GetAccountWithBalance(ctx context.Context, id uuid.UUID) (GetAccountWithBalanceRow, error) {
	row := q.db.QueryRow(ctx, getAccountWithBalance, id)
	var i GetAccountWithBalanceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentBalance,
		&i.PendingBalance,
		&i.AvailableBalance,
	)
	return i, err
}

const getAccountsWithBalances = `-- name: GetAccountsWithBalances :many
SELECT 
    a.id, a.name, a.type, a.description, a.created_at, a.updated_at,
    COALESCE(b.current_balance, 0) as current_balance,
    COALESCE(b.pending_balance, 0) as pending_balance,
    COALESCE(b.available_balance, 0) as available_balance
FROM accounts a
LEFT JOIN balances b ON a.id = b.account_id
ORDER BY a.name
`

type GetAccountsWithBalancesRow struct {
	ID               uuid.UUID `json:"id"`
	Name             string    `json:"name"`
	Type             string    `json:"type"`
	Description      *string   `json:"description"`
	CreatedAt        time.Time `json:"createdAt"`
	UpdatedAt        time.Time `json:"updatedAt"`
	CurrentBalance   big.Int   `json:"currentBalance"`
	PendingBalance   big.Int   `json:"pendingBalance"`
	AvailableBalance big.Int   `json:"availableBalance"`
}

func (q *Queries) GetAccountsWithBalances(ctx context.Context) ([]GetAccountsWithBalancesRow, error) {
	rows, err := q.db.Query(ctx, getAccountsWithBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsWithBalancesRow
	for rows.Next() {
		var i GetAccountsWithBalancesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentBalance,
			&i.PendingBalance,
			&i.AvailableBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAccounts = `-- name: GetAllAccounts :many
SELECT id, name, type, description, created_at, updated_at
FROM accounts
ORDER BY name
`

func (q *Queries) GetAllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBalances = `-- name: GetAllBalances :many
SELECT account_id, current_balance, pending_balance, available_balance, last_calculated
FROM balances
ORDER BY account_id
`

func (q *Queries) GetAllBalances(ctx context.Context) ([]Balance, error) {
	rows, err := q.db.Query(ctx, getAllBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Balance
	for rows.Next() {
		var i Balance
		if err := rows.Scan(
			&i.AccountID,
			&i.CurrentBalance,
			&i.PendingBalance,
			&i.AvailableBalance,
			&i.LastCalculated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCategories = `-- name: GetAllCategories :many
SELECT id, name, type, description, color, created_at, updated_at
FROM categories
ORDER BY type, name
`

func (q *Queries) GetAllCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTransactions = `-- name: GetAllTransactions :many
SELECT id, account_id, category_id, amount, description, date, status, created_at, updated_at
FROM transactions
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetAllTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getAllTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceByAccountID = `-- name: GetBalanceByAccountID :one

SELECT account_id, current_balance, pending_balance, available_balance, last_calculated
FROM balances
WHERE account_id = $1
`

// =============================================================================
// BALANCES
// =============================================================================
func (q *Queries) GetBalanceByAccountID(ctx context.Context, accountID uuid.UUID) (Balance, error) {
	row := q.db.QueryRow(ctx, getBalanceByAccountID, accountID)
	var i Balance
	err := row.Scan(
		&i.AccountID,
		&i.CurrentBalance,
		&i.PendingBalance,
		&i.AvailableBalance,
		&i.LastCalculated,
	)
	return i, err
}

const getBalanceSummary = `-- name: GetBalanceSummary :one
SELECT 
    COALESCE(SUM(CASE WHEN a.type IN ('checking', 'savings', 'investment', 'cash') THEN b.current_balance ELSE 0 END), 0) as total_assets,
    COALESCE(SUM(CASE WHEN a.type = 'credit' THEN ABS(b.current_balance) ELSE 0 END), 0) as total_liabilities,
    COALESCE(SUM(CASE WHEN a.type IN ('checking', 'savings', 'investment', 'cash') THEN b.current_balance ELSE -ABS(b.current_balance) END), 0) as net_worth,
    NOW() as last_calculated
FROM balances b
JOIN accounts a ON b.account_id = a.id
`

type GetBalanceSummaryRow struct {
	TotalAssets      interface{} `json:"totalAssets"`
	TotalLiabilities interface{} `json:"totalLiabilities"`
	NetWorth         interface{} `json:"netWorth"`
	LastCalculated   interface{} `json:"lastCalculated"`
}

func (q *Queries) GetBalanceSummary(ctx context.Context) (GetBalanceSummaryRow, error) {
	row := q.db.QueryRow(ctx, getBalanceSummary)
	var i GetBalanceSummaryRow
	err := row.Scan(
		&i.TotalAssets,
		&i.TotalLiabilities,
		&i.NetWorth,
		&i.LastCalculated,
	)
	return i, err
}

const getCategoriesByType = `-- name: GetCategoriesByType :many
SELECT id, name, type, description, color, created_at, updated_at
FROM categories
WHERE type = $1
ORDER BY name
`

func (q *Queries) GetCategoriesByType(ctx context.Context, type_ string) ([]Category, error) {
	rows, err := q.db.Query(ctx, getCategoriesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, type, description, color, created_at, updated_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, account_id, category_id, amount, description, date, status, created_at, updated_at
FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionWithDetails = `-- name: GetTransactionWithDetails :one

SELECT 
    t.id, t.account_id, t.category_id, t.amount, t.description, t.date, t.status, t.created_at, t.updated_at,
    a.name as account_name, a.type as account_type,
    c.name as category_name, c.type as category_type, c.color as category_color
FROM transactions t
JOIN accounts a ON t.account_id = a.id
JOIN categories c ON t.category_id = c.id
WHERE t.id = $1
`

type GetTransactionWithDetailsRow struct {
	ID            uuid.UUID   `json:"id"`
	AccountID     uuid.UUID   `json:"accountId"`
	CategoryID    uuid.UUID   `json:"categoryId"`
	Amount        big.Int     `json:"amount"`
	Description   string      `json:"description"`
	Date          pgtype.Date `json:"date"`
	Status        string      `json:"status"`
	CreatedAt     time.Time   `json:"createdAt"`
	UpdatedAt     time.Time   `json:"updatedAt"`
	AccountName   string      `json:"accountName"`
	AccountType   string      `json:"accountType"`
	CategoryName  string      `json:"categoryName"`
	CategoryType  string      `json:"categoryType"`
	CategoryColor *string     `json:"categoryColor"`
}

// =============================================================================
// JOINED QUERIES FOR DETAILED VIEWS
// =============================================================================
func (q *Queries) GetTransactionWithDetails(ctx context.Context, id uuid.UUID) (GetTransactionWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getTransactionWithDetails, id)
	var i GetTransactionWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountName,
		&i.AccountType,
		&i.CategoryName,
		&i.CategoryType,
		&i.CategoryColor,
	)
	return i, err
}

const getTransactionsByAccount = `-- name: GetTransactionsByAccount :many
SELECT id, account_id, category_id, amount, description, date, status, created_at, updated_at
FROM transactions
WHERE account_id = $1
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetTransactionsByAccount(ctx context.Context, accountID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByAccountAndDateRange = `-- name: GetTransactionsByAccountAndDateRange :many
SELECT id, account_id, category_id, amount, description, date, status, created_at, updated_at
FROM transactions
WHERE account_id = $1 AND date >= $2 AND date <= $3
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetTransactionsByAccountAndDateRange(ctx context.Context, accountID uuid.UUID, date pgtype.Date, date_2 pgtype.Date) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByAccountAndDateRange, accountID, date, date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByCategory = `-- name: GetTransactionsByCategory :many
SELECT id, account_id, category_id, amount, description, date, status, created_at, updated_at
FROM transactions
WHERE category_id = $1
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetTransactionsByCategory(ctx context.Context, categoryID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT id, account_id, category_id, amount, description, date, status, created_at, updated_at
FROM transactions
WHERE date >= $1 AND date <= $2
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, date pgtype.Date, date_2 pgtype.Date) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByDateRange, date, date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsWithDetails = `-- name: GetTransactionsWithDetails :many
SELECT 
    t.id, t.account_id, t.category_id, t.amount, t.description, t.date, t.status, t.created_at, t.updated_at,
    a.name as account_name, a.type as account_type,
    c.name as category_name, c.type as category_type, c.color as category_color
FROM transactions t
JOIN accounts a ON t.account_id = a.id
JOIN categories c ON t.category_id = c.id
ORDER BY t.date DESC, t.created_at DESC
LIMIT $1 OFFSET $2
`

type GetTransactionsWithDetailsRow struct {
	ID            uuid.UUID   `json:"id"`
	AccountID     uuid.UUID   `json:"accountId"`
	CategoryID    uuid.UUID   `json:"categoryId"`
	Amount        big.Int     `json:"amount"`
	Description   string      `json:"description"`
	Date          pgtype.Date `json:"date"`
	Status        string      `json:"status"`
	CreatedAt     time.Time   `json:"createdAt"`
	UpdatedAt     time.Time   `json:"updatedAt"`
	AccountName   string      `json:"accountName"`
	AccountType   string      `json:"accountType"`
	CategoryName  string      `json:"categoryName"`
	CategoryType  string      `json:"categoryType"`
	CategoryColor *string     `json:"categoryColor"`
}

func (q *Queries) GetTransactionsWithDetails(ctx context.Context, limit int32, offset int32) ([]GetTransactionsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getTransactionsWithDetails, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsWithDetailsRow
	for rows.Next() {
		var i GetTransactionsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.CategoryID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountName,
			&i.AccountType,
			&i.CategoryName,
			&i.CategoryType,
			&i.CategoryColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshAccountBalance = `-- name: RefreshAccountBalance :exec
SELECT update_account_balance($1)
`

func (q *Queries) RefreshAccountBalance(ctx context.Context, accountUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, refreshAccountBalance, accountUuid)
	return err
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET name = $2, type = $3, description = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, name, type, description, created_at, updated_at
`

func (q *Queries) UpdateAccount(ctx context.Context, iD uuid.UUID, name string, type_ string, description *string) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		iD,
		name,
		type_,
		description,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name = $2, type = $3, description = $4, color = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, name, type, description, color, created_at, updated_at
`

func (q *Queries) UpdateCategory(ctx context.Context, iD uuid.UUID, name string, type_ string, description *string, color *string) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		iD,
		name,
		type_,
		description,
		color,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET account_id = $2, category_id = $3, amount = $4, description = $5, date = $6, status = $7, updated_at = NOW()
WHERE id = $1
RETURNING id, account_id, category_id, amount, description, date, status, created_at, updated_at
`

func (q *Queries) UpdateTransaction(ctx context.Context, iD uuid.UUID, accountID uuid.UUID, categoryID uuid.UUID, amount big.Int, description string, date pgtype.Date, status string) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		iD,
		accountID,
		categoryID,
		amount,
		description,
		date,
		status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, account_id, category_id, amount, description, date, status, created_at, updated_at
`

func (q *Queries) UpdateTransactionStatus(ctx context.Context, iD uuid.UUID, status string) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, iD, status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CategoryID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
