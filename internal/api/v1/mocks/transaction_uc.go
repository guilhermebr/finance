// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"finance/domain/entities"
	"sync"
)

// TransactionUseCaseMock is a mock implementation of v1.TransactionUseCase.
//
//	func TestSomethingThatUsesTransactionUseCase(t *testing.T) {
//
//		// make and configure a mocked v1.TransactionUseCase
//		mockedTransactionUseCase := &TransactionUseCaseMock{
//			CreateTransactionFunc: func(ctx context.Context, transaction entities.Transaction) (entities.Transaction, error) {
//				panic("mock out the CreateTransaction method")
//			},
//			DeleteTransactionFunc: func(ctx context.Context, id string) error {
//				panic("mock out the DeleteTransaction method")
//			},
//			GetTransactionWithDetailsFunc: func(ctx context.Context, id string) (entities.Transaction, error) {
//				panic("mock out the GetTransactionWithDetails method")
//			},
//			GetTransactionsWithDetailsFunc: func(ctx context.Context, limit int, offset int) ([]entities.Transaction, error) {
//				panic("mock out the GetTransactionsWithDetails method")
//			},
//			UpdateTransactionFunc: func(ctx context.Context, transaction entities.Transaction) (entities.Transaction, error) {
//				panic("mock out the UpdateTransaction method")
//			},
//		}
//
//		// use mockedTransactionUseCase in code that requires v1.TransactionUseCase
//		// and then make assertions.
//
//	}
type TransactionUseCaseMock struct {
	// CreateTransactionFunc mocks the CreateTransaction method.
	CreateTransactionFunc func(ctx context.Context, transaction entities.Transaction) (entities.Transaction, error)

	// DeleteTransactionFunc mocks the DeleteTransaction method.
	DeleteTransactionFunc func(ctx context.Context, id string) error

	// GetTransactionWithDetailsFunc mocks the GetTransactionWithDetails method.
	GetTransactionWithDetailsFunc func(ctx context.Context, id string) (entities.Transaction, error)

	// GetTransactionsWithDetailsFunc mocks the GetTransactionsWithDetails method.
	GetTransactionsWithDetailsFunc func(ctx context.Context, limit int, offset int) ([]entities.Transaction, error)

	// UpdateTransactionFunc mocks the UpdateTransaction method.
	UpdateTransactionFunc func(ctx context.Context, transaction entities.Transaction) (entities.Transaction, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateTransaction holds details about calls to the CreateTransaction method.
		CreateTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Transaction is the transaction argument value.
			Transaction entities.Transaction
		}
		// DeleteTransaction holds details about calls to the DeleteTransaction method.
		DeleteTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetTransactionWithDetails holds details about calls to the GetTransactionWithDetails method.
		GetTransactionWithDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetTransactionsWithDetails holds details about calls to the GetTransactionsWithDetails method.
		GetTransactionsWithDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// UpdateTransaction holds details about calls to the UpdateTransaction method.
		UpdateTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Transaction is the transaction argument value.
			Transaction entities.Transaction
		}
	}
	lockCreateTransaction          sync.RWMutex
	lockDeleteTransaction          sync.RWMutex
	lockGetTransactionWithDetails  sync.RWMutex
	lockGetTransactionsWithDetails sync.RWMutex
	lockUpdateTransaction          sync.RWMutex
}

// CreateTransaction calls CreateTransactionFunc.
func (mock *TransactionUseCaseMock) CreateTransaction(ctx context.Context, transaction entities.Transaction) (entities.Transaction, error) {
	callInfo := struct {
		Ctx         context.Context
		Transaction entities.Transaction
	}{
		Ctx:         ctx,
		Transaction: transaction,
	}
	mock.lockCreateTransaction.Lock()
	mock.calls.CreateTransaction = append(mock.calls.CreateTransaction, callInfo)
	mock.lockCreateTransaction.Unlock()
	if mock.CreateTransactionFunc == nil {
		var (
			transactionOut entities.Transaction
			errOut         error
		)
		return transactionOut, errOut
	}
	return mock.CreateTransactionFunc(ctx, transaction)
}

// CreateTransactionCalls gets all the calls that were made to CreateTransaction.
// Check the length with:
//
//	len(mockedTransactionUseCase.CreateTransactionCalls())
func (mock *TransactionUseCaseMock) CreateTransactionCalls() []struct {
	Ctx         context.Context
	Transaction entities.Transaction
} {
	var calls []struct {
		Ctx         context.Context
		Transaction entities.Transaction
	}
	mock.lockCreateTransaction.RLock()
	calls = mock.calls.CreateTransaction
	mock.lockCreateTransaction.RUnlock()
	return calls
}

// DeleteTransaction calls DeleteTransactionFunc.
func (mock *TransactionUseCaseMock) DeleteTransaction(ctx context.Context, id string) error {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteTransaction.Lock()
	mock.calls.DeleteTransaction = append(mock.calls.DeleteTransaction, callInfo)
	mock.lockDeleteTransaction.Unlock()
	if mock.DeleteTransactionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteTransactionFunc(ctx, id)
}

// DeleteTransactionCalls gets all the calls that were made to DeleteTransaction.
// Check the length with:
//
//	len(mockedTransactionUseCase.DeleteTransactionCalls())
func (mock *TransactionUseCaseMock) DeleteTransactionCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteTransaction.RLock()
	calls = mock.calls.DeleteTransaction
	mock.lockDeleteTransaction.RUnlock()
	return calls
}

// GetTransactionWithDetails calls GetTransactionWithDetailsFunc.
func (mock *TransactionUseCaseMock) GetTransactionWithDetails(ctx context.Context, id string) (entities.Transaction, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTransactionWithDetails.Lock()
	mock.calls.GetTransactionWithDetails = append(mock.calls.GetTransactionWithDetails, callInfo)
	mock.lockGetTransactionWithDetails.Unlock()
	if mock.GetTransactionWithDetailsFunc == nil {
		var (
			transactionOut entities.Transaction
			errOut         error
		)
		return transactionOut, errOut
	}
	return mock.GetTransactionWithDetailsFunc(ctx, id)
}

// GetTransactionWithDetailsCalls gets all the calls that were made to GetTransactionWithDetails.
// Check the length with:
//
//	len(mockedTransactionUseCase.GetTransactionWithDetailsCalls())
func (mock *TransactionUseCaseMock) GetTransactionWithDetailsCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetTransactionWithDetails.RLock()
	calls = mock.calls.GetTransactionWithDetails
	mock.lockGetTransactionWithDetails.RUnlock()
	return calls
}

// GetTransactionsWithDetails calls GetTransactionsWithDetailsFunc.
func (mock *TransactionUseCaseMock) GetTransactionsWithDetails(ctx context.Context, limit int, offset int) ([]entities.Transaction, error) {
	callInfo := struct {
		Ctx    context.Context
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetTransactionsWithDetails.Lock()
	mock.calls.GetTransactionsWithDetails = append(mock.calls.GetTransactionsWithDetails, callInfo)
	mock.lockGetTransactionsWithDetails.Unlock()
	if mock.GetTransactionsWithDetailsFunc == nil {
		var (
			transactionsOut []entities.Transaction
			errOut          error
		)
		return transactionsOut, errOut
	}
	return mock.GetTransactionsWithDetailsFunc(ctx, limit, offset)
}

// GetTransactionsWithDetailsCalls gets all the calls that were made to GetTransactionsWithDetails.
// Check the length with:
//
//	len(mockedTransactionUseCase.GetTransactionsWithDetailsCalls())
func (mock *TransactionUseCaseMock) GetTransactionsWithDetailsCalls() []struct {
	Ctx    context.Context
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		Limit  int
		Offset int
	}
	mock.lockGetTransactionsWithDetails.RLock()
	calls = mock.calls.GetTransactionsWithDetails
	mock.lockGetTransactionsWithDetails.RUnlock()
	return calls
}

// UpdateTransaction calls UpdateTransactionFunc.
func (mock *TransactionUseCaseMock) UpdateTransaction(ctx context.Context, transaction entities.Transaction) (entities.Transaction, error) {
	callInfo := struct {
		Ctx         context.Context
		Transaction entities.Transaction
	}{
		Ctx:         ctx,
		Transaction: transaction,
	}
	mock.lockUpdateTransaction.Lock()
	mock.calls.UpdateTransaction = append(mock.calls.UpdateTransaction, callInfo)
	mock.lockUpdateTransaction.Unlock()
	if mock.UpdateTransactionFunc == nil {
		var (
			transactionOut entities.Transaction
			errOut         error
		)
		return transactionOut, errOut
	}
	return mock.UpdateTransactionFunc(ctx, transaction)
}

// UpdateTransactionCalls gets all the calls that were made to UpdateTransaction.
// Check the length with:
//
//	len(mockedTransactionUseCase.UpdateTransactionCalls())
func (mock *TransactionUseCaseMock) UpdateTransactionCalls() []struct {
	Ctx         context.Context
	Transaction entities.Transaction
} {
	var calls []struct {
		Ctx         context.Context
		Transaction entities.Transaction
	}
	mock.lockUpdateTransaction.RLock()
	calls = mock.calls.UpdateTransaction
	mock.lockUpdateTransaction.RUnlock()
	return calls
}
